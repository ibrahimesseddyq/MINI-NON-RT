==146832==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x621000002508 at pc 0x564f495a9214 bp 0x7ffd6fd4fb50 sp 0x7ffd6fd4fb40
WRITE of size 1 at 0x621000002508 thread T0
    #0 0x564f495a9213 in ft_split mand/src/utils/ft_split.c:59
    #1 0x564f495a83ec in splil_line mand/src/parsing/parsing.c:25
    #2 0x564f495b3e2f in process_flie mand/src/parsing/read_line.c:95
    #3 0x564f495a7c20 in main /home/sessarhi/Desktop/minirt/minirt.c:22
    #4 0x7fb182315d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #5 0x7fb182315e3f in __libc_start_main_impl ../csu/libc-start.c:392
    #6 0x564f495a7a64 in _start (/home/sessarhi/Desktop/minirt/miniRT+0x3a64)

0x621000002508 is located 8 bytes to the right of 4096-byte region [0x621000001500,0x621000002500)
allocated by thread T0 here:
    #0 0x7fb182805887 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145
    #1 0x564f495a9f7d in arena_allocate_chunk mand/src/memory/arena_alloc.c:32
    #2 0x564f495aa18b in arena_aligned_alloc mand/src/memory/arena_alloc.c:61
    #3 0x564f495aa2dc in arena_alloc mand/src/memory/arena_alloc.c:79
    #4 0x564f495a9060 in ft_split mand/src/utils/ft_split.c:50
    #5 0x564f495a839f in splil_line mand/src/parsing/parsing.c:22
    #6 0x564f495b3e2f in process_flie mand/src/parsing/read_line.c:95
    #7 0x564f495a7c20 in main /home/sessarhi/Desktop/minirt/minirt.c:22
    #8 0x7fb182315d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58

SUMMARY: AddressSanitizer: heap-buffer-overflow mand/src/utils/ft_split.c:59 in ft_split
Shadow bytes around the buggy address:
  0x0c427fff8450: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c427fff8460: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c427fff8470: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c427fff8480: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c427fff8490: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0c427fff84a0: fa[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c427fff84b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c427fff84c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c427fff84d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c427fff84e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c427fff84f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==146832==ABORTING
the problem still accures here the whole code i want it to be well protected against any edge case
# define ARENA_ALIGNMENT 8
# define DEFAULT_CHUNK_SIZE 4096
# define MIN_CHUNK_SIZE 4096
typedef struct s_arena_chunk
{
	struct s_arena_chunk	*next;
	size_t					size;
	size_t					used;
	uintptr_t				data[];
}	t_arena_chunk;

typedef struct s_arena
{
	t_arena_chunk	*current;
	t_arena_chunk	*first;
	size_t			chunk_size;
	size_t			total_allocated;
	size_t			total_used;
	bool			allow_resize;
	void			*(*alloc_fn)(size_t);
	void			(*free_fn)(void*);
}	t_arena;

typedef struct s_arena_save
{
	t_arena			*arena;
	t_arena_chunk	*saved_chunk;
	size_t			saved_used;
	size_t			saved_total;
}	t_arena_save;
size_t	align_up(size_t n, size_t align)
{
	return (((n) + (align) - 1) & ~((align) - 1));
}

t_arena_chunk *arena_allocate_chunk(t_arena *arena, size_t min_size)
{
    size_t chunk_size;
    t_arena_chunk *chunk;

    chunk_size = arena->chunk_size;
    if (min_size > chunk_size - sizeof(t_arena_chunk))
    {
        chunk_size = min_size + sizeof(t_arena_chunk);
        chunk_size = align_up(chunk_size, ARENA_ALIGNMENT);
    }

    chunk = (t_arena_chunk *)arena->alloc_fn(chunk_size);
    if (!chunk)
        return (NULL);

    chunk->next = NULL;
    chunk->size = chunk_size;
    chunk->used = 0;
    arena->total_allocated += chunk_size;
    return (chunk);
}

void *arena_aligned_alloc(t_arena *arena, size_t size, size_t align)
{
    void *ptr;
    t_arena_chunk *new_chunk;

    if (size == 0)
        return (NULL);

    if (align < ARENA_ALIGNMENT)
        align = ARENA_ALIGNMENT;

    ptr = arena_alloc_from_chunk(arena->current, size, align);
    if (ptr)
        return (arena->total_used += size, ptr);

    if (!arena->allow_resize)
        return (NULL);

    new_chunk = arena_allocate_chunk(arena, size + align);
    if (!new_chunk)
        return (NULL);

    new_chunk->next = arena->current->next;
    arena->current->next = new_chunk;
    arena->current = new_chunk;

    ptr = arena_alloc_from_chunk(new_chunk, size, align);
    if (ptr)
        arena->total_used += size;

    return (ptr);
}

void	*arena_alloc(t_arena	*arena, size_t size)
{
	void	*ptr;
	ptr = arena_aligned_alloc(arena, size, ARENA_ALIGNMENT);
	if (!ptr)
		clean_exit("Memory allocation failed");
	return (ptr);
}

void *arena_alloc_from_chunk(t_arena_chunk *chunk, size_t size, size_t align)
{
    uintptr_t current;
    uintptr_t aligned;
    size_t padding;
    size_t total_size;

    current = (uintptr_t)&chunk->data[chunk->used];
    aligned = align_up(current, align);
    padding = aligned - current;
    total_size = padding + size;
    if (chunk->used + total_size > chunk->size)
        return (NULL);

    chunk->used += total_size;
    return ((void *)aligned);
}
t_arena	*arena_create(void)
{
	return (arena_create_with_params(DEFAULT_CHUNK_SIZE, true, malloc, free));
}

t_arena	*arena_create_with_params(size_t chunk_size, bool allow_resize,
			void *(*alloc_fn)(size_t), void (*free_fn)(void*))
{
	t_arena			*arena;
	t_arena_chunk	*chunk;

	if (chunk_size < MIN_CHUNK_SIZE)
		chunk_size = MIN_CHUNK_SIZE;
	chunk_size = align_up(chunk_size, ARENA_ALIGNMENT);
	if (!alloc_fn)
		alloc_fn = malloc;
	if (!free_fn)
		free_fn = free;
	arena = (t_arena *)alloc_fn(sizeof(t_arena));
	if (!arena)
		return (NULL);
	arena->chunk_size = chunk_size;
	arena->allow_resize = allow_resize;
	arena->total_allocated = 0;
	arena->total_used = 0;
	arena->alloc_fn = alloc_fn;
	arena->free_fn = free_fn;
	chunk = arena_allocate_chunk(arena, chunk_size);
	if (!chunk)
		return (free_fn(arena), NULL);
	arena->first = chunk;
	arena->current = chunk;
	return (arena);
}

size_t	arena_total_allocated(const t_arena	*arena)
{
	if (arena)
		return (arena->total_allocated);
	return (0);
}
void	arena_reset(t_arena	*arena)
{
	t_arena_chunk	*chunk;

	if (!arena)
		return ;
	chunk = arena->first;
	while (chunk)
	{
		chunk->used = 0;
		chunk = chunk->next;
	}
	arena->current = arena->first;
	arena->total_used = 0;
}

void	arena_destroy(t_arena	*arena)
{
	t_arena_chunk	*chunk;
	t_arena_chunk	*next;

	if (!arena)
		return ;
	chunk = arena->first;
	while (chunk)
	{
		next = chunk->next;
		arena->free_fn(chunk);
		chunk = next;
	}
	arena->free_fn(arena);
}

size_t	arena_total_used(const t_arena	*arena)
{
	if (arena)
		return (arena->total_used);
	return (0);
}

t_arena_save	arena_save(t_arena	*arena)
{
	t_arena_save	save;

	save.arena = arena;
	save.saved_chunk = arena->current;
	save.saved_used = arena->current->used;
	save.saved_total = arena->total_used;
	return (save);
}

void	arena_restore(t_arena_save save)
{
	t_arena			*arena;
	t_arena_chunk	*chunk;
	t_arena_chunk	*next;

	arena = save.arena;
	if (!arena)
		return ;
	chunk = save.saved_chunk->next;
	while (chunk)
	{
		next = chunk->next;
		arena->free_fn(chunk);
		chunk = next;
	}	
	save.saved_chunk->next = NULL;
	save.saved_chunk->used = save.saved_used;
	arena->current = save.saved_chunk;
	arena->total_used = save.saved_total;
}
t_arena	**get_arena(void)
{
	static t_arena	*arena;

	return (&arena);
}

void	set_arena(t_arena	*new_arena)
{
	t_arena	**arena;

	arena = get_arena();
	*arena = new_arena;
}

void	setup_arena(void)
{
	t_arena	*arena;

	arena = arena_create();
	if (!arena)
	{
		printf("Error: arena creation failed\n");
		exit(1);
	}
	set_arena(arena);
}

